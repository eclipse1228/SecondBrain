
# 데이터표현법

*bit*: 0 또는 1로서 정보를 표현하는 최소 단위 (이진법 1자리)
1 Byte = 8 bit 
nibble : 바이트의 절반에 해당하는 4 비트 데이터 세트입니다. 
word : 컴퓨터의 연산의 기본 단위가 되는 정보의 양 2 byte , 4 byte 보통 4임 컴파일러에 따라 다르다.

### ex 1byte에서 ![[lsb.png]]
오른쪽 끝 최하위비트 lsb 0번 비트
왼쪽 끝 최상위비트 msb 7번 비트 
0~3번 하위 니블
4~7번 상위 니블
(워드에서는 바이트로 상위 하위를 얘기한다.)

기계는 0과 1을 알아듣는다. (low 와 high를 알아 듣는다. 전압레벨로 알아듣는것이다.)

## 진법 변환
8자리 다 써 줘야함 아트매가에서는 그렇게함.
0b의 뜻은 다음은 2진법입니다.
ox는 다음은 16진법입니다. 라는 뜻임.
(ob00001000)
(ox37)
2진수 -> 10진수
방법: 2진수의 자릿수는 2^n이다. 오른쪽 끝은 2^1 이후 2^2...
ex) 0001 -> 1 

10진수-> 2진수
방법: 2로 나눠서  
ex) 8 -> 1000
![[2진.png]]
2진수 -> 16진수
ex) ob00001000 -> ox3E8
16진수 -> 2진수
8 => 1000 ,A => 1010 이다. 이것을 토대로 변경
## 16진법을 쓰는 이유
기계과는 제어가 목적이라서, 기계가 바로 알아들을 수 있게 처리한다. 이진법 쓴다.
길어가지고 실수날거 같으니까 16진법을 넣는다. 

컴공에서는 나중에 메모리 들어가보면 전부 16진법으로 되어있다. 
그냥 16진법 보면 튀어나와야한다.


# Atmega128 
## 8bit MCU

아두이노 우노 먼저 할 거임

### 변수는 메모리 공간이다 
변수 선언은 이름을 붙여주는것이다. 

## 변수와 자료형  

- 컴파일러마다 조금씩 다르다.
- char은 무조건 1 바이트 (아스키코드 변형 가능 , 아스키코드 -> ))
- int 4 or 2 
- float 4 
```c
char date = 0;
data = 1000;
```
컴파일은 되는데 동작은 안 한다.
data에 1000이 전부 다 못 들어간다. 숫자 몇개가 못 들어간다. (
1000 -> ob1111101000
![[1000.png]]
오른쪽 끝부터 들어간다. 최하위))
255되고나서 다시 0가된다.

```c
int data=0;
for(data=0; data<1000; data++)
{ 
}
```

(이거 절대 1000못됨 무한히 돈다.)
- 전문가는 bool 형 많이 쓴다 1비트짜리 

## 변수의 범위

**전역변수** : 함수외부에서 선언해서 프로그램 전체에서 사용하는 변수
(전역변수는 프로그램메모리(데이터영역)로 들어가기 때문에 아껴써야한다.)

**지역변수**: 함수 내부에서 선언해서 선언되어진 함수에서 독립적으로 사용하는 변수이다 .
(포인터를 이용해서 사용성 높일 수 있음) 

## 배열
변수 선언하는데만 세월이다! 

```c
int data[3] = {5,1,3}

int data[] = {5,1,3}
//도 된다 but, 속도가 느려진다. 컴파일러가 나중에 커지면 또 늘려야하니까)
```
30,31 번지 :5
32,33 번지 :1
34,35 번지 : 3
와 같은 구조로 메모리에 올라간다.
## 구조체 
형이 많이 다양한 것을 넣는 배열.. 선언하고 싶다.. 그런 배열은 없다! 

문법은 원형과 흐름을 중심으로 봐야한다.

조건문 
## if문 - if() { } 
```c
if(조건) { 
실행문;
}
```
## if-else
```c
if(조건문) {

}
else if() { 

}

else {

}
```
if문의 조건이 아니라면, else if 조건문으로 가고, 그것도 아니면 else로 간다.
만약 if와 else문만 있다면 if가 아니면 바로 else문을 실행한다. 
## switch - case
조건문속 경우를 케이스로 나눠 실행한다. 하지만 특정 케이스에 실행하는것이 아니라 그 케이스가 맞다면, 그 아래 케이스도 모두 실행한다. 
## break 
- break; 은 가까운 함수를 탈출하는것이다. 
swtich는 시작위치를 결정하는것이다. 특정 케이스에 실행하는게 아니라! 
break가 따로 붙는것이다!
```c
int count = 1;
switch(count) { 
case 1: 
case 2:
case 3: 
case 4:
}
```

1234

스위치문은 동작형태가 계속 케이스가 맞는지 확인하는것이다. ( 그래서 반복문임)
![[Pasted image 20231228135543.png]]
- default는 어떤 케이스던 종료전 실행한다. (이전에 break 만나면 default는 실행 x )

## while
while문은 특정조건에 실행할때 많이 쓴다 .
```c
while(조건문) {실행문;}

do {실행문; }
while(조건);
```
- do while
while문 끝에 ; 붙여야함
do while은 일단 한번 실행하고, 조건에 따라 while.


# 연산자

### 산술연산자 : +,-,(별표*),/,%
- +,- : 더하기 빼기
- 별표* : 곱하기
- / : 나누기, 몫
- % : 나머지연산  
```c
// 3의 배수이고 8의 배수일때 ~ 해라
if( a % 3 == 0 && a % 8 == 0 ) { } 
```
### 비교 연산자: == , != , ><>=<=(대입은 항상 오른쪽에),
- == : 같다
- != : 같지 않다.
- > : 크다
- < : 작다
- >= 크거나 같다
- <= 작거나 같다.
### 논리연산자: and , or ,xor , not 
- && : and 기호 , 왼쪽과 오른쪽에 조건이 나온다. 조건 && 조건
- & : 변수,상수 & 숫자      비트별 and 단일연산 (비트연산)
ex) 0x3e & ox50 
0011 1110   ob1111 0000
이거 두 개를 and 연산하는거다 .

& -> 특정한 위치의 값을 0으로 바꾸고 다른건 유지하고싶을떄 쓴다.

방법 -> 0으로 바뀔 위치에 0 유지하고자하는 위치에 1 새로운 값을 만들어서 두 개 and연산
ex) 0b1100 0101
7번이랑 6번 비트를 0으로 바꾸고싶다 나머지는 유지하고.
(이거 ob 0000 0101 넣으면 안되나?  안됨 그건 '유지'가 아니라 바뀌는거임)

00을 넣고 유지하고 자하는 값에 1을 넣는다. -> 00 111111
A = Afob001111111 이러면 유지 된거임
(특정한 위치를 0으로 바꾸고)
ex) 
11000101
00111111
(and연산!)->
00000101

- ||  : or 기호 (양쪽은 조건)
| : or (비트연산)
or연산은 특정한 값을 1로 바꾸고 나머지는 0으로 유지
1로 바꾸고자 하는 위치에 1 , 유지하고자 하는 곳에 0
- ~ not 연산 1은 0으로 0은 1로
- ^ 은 xor 연산 얘는 2개 짜리 없음. 2진법으로 바꿔서 xor연산
111111 (0xff) 으로 xor 시키면 반전된다.  
#### 진리표 보고 불공식 만들기
#### and 불 대 기본 공식
A (and) 0 = 0 
A 1 = A
A A = A 
A !A = 0 
#### OR 불 대수 기본 공리


##   기타연산 : 
- >> << 시프트 연산 
	A >> B 
	A를 B비트만큼 오른쪽으로 시프트시키시오.
1. 0x80 >> 3 ;
2. ob1000 0000
3. 빈공간은 0으로 채워넣는다.
4. 오른쪽 시프트면 나누기 2, 왼쪽으로는 곱하기 2 
   ALU 밖에 없기 때문에 , 
   (ex 오른쪽 시프트는 오른쪽에 그만큼 지우고 왼쪽에 그만큼 붙여 0을 왼쪽도 마찬가지 로직)
#### a ? b : c  (3항 연산자)
a가 참이면 b 실행 , a가 거짓이면 c 실행
```c
data = a>5?3:4
```
### 대입연산자 a = b 
   - 복합 대입연산  += (이거 과정이다르다! 
   - A = A+B 하면 2번에 걸쳐 동작하는데, 1 ) A+B를 한다 2) A에 대입 .) but A+=B 하면 A+B해서 A에 넣는다 . 즉 한 번에 한다. (속도 처리차이가 생김)
전치 후치 ++ 
A=1;
B=0;
B = A ++ 하면
output
B=1 이고 , A=2가 된다.

B = ++A;하면
A=2 , B=2
